# -*- coding: utf-8 -*-
"""cd

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1w936bQLmgZ6hYWJ_goVaqMh0O9N9OEV3

Este código em Python realiza um método chamado "stepwise selection" para seleção de variáveis em um modelo de regressão linear usando a biblioteca statsmodels. Aqui estão as principais etapas do código:

Importação de bibliotecas:

pandas para manipulação de dados.
statsmodels para realizar a regressão linear.
numpy para operações numéricas.
Carregamento dos dados:

Os dados são carregados a partir de um arquivo CSV chamado "tb_lobby_stats_player.csv" usando a biblioteca pandas e armazenados na variável data.
Definição da função stepwise_selection:

Esta função realiza o método stepwise para seleção de variáveis em um modelo de regressão linear.
É uma combinação de etapas "forward" (adição de variáveis) e "backward" (remoção de variáveis) para escolher as melhores variáveis explicativas.
O critério de inclusão (threshold_in) e exclusão (threshold_out) são baseados nos valores de p-valor.
Exemplo de uso:

A variável X recebe todas as colunas do conjunto de dados, exceto a coluna "qtKill" (variável dependente).
A variável y recebe a coluna "qtKill".
A função stepwise_selection é chamada com as variáveis X e y, e o resultado é armazenado em result.
Impressão do resultado:

As variáveis selecionadas pelo método stepwise são impressas na saída.
O método stepwise é utilizado para ajudar na escolha das variáveis mais relevantes para incluir em um modelo de regressão linear, tentando evitar overfitting e selecionar as variáveis mais significativas. O código parece bem estruturado e é uma abordagem comum para a seleção de variáveis em estatísticas e análise de dados.
"""

import pandas as pd
import statsmodels.api as sm
import numpy as np

# Carregando os dados
data = pd.read_csv("tb_lobby_stats_player.csv")

# Função para realizar o método stepwise
def stepwise_selection(X, y, initial_list=[], threshold_in=0.01, threshold_out=0.05, verbose=True):
    included = list(initial_list)
    while True:
        changed = False
        # forward step
        excluded = list(set(X.columns) - set(included))
        new_pval = pd.Series(index=excluded, dtype='float64')
        for new_column in excluded:
            model_data = sm.add_constant(pd.DataFrame(X[included + [new_column]]))

            # Verificando se todas as colunas são numéricas
            if model_data.select_dtypes(include=[np.number]).shape[1] == model_data.shape[1]:
                if not model_data[included + [new_column]].isnull().any().any():
                    model = sm.OLS(y, model_data).fit()
                    new_pval[new_column] = model.pvalues[new_column]

        best_pval = new_pval.min()
        if best_pval < threshold_in:
            best_feature = new_pval.idxmin()
            included.append(best_feature)
            changed = True
            if verbose:
                print('Add  {:30} with p-value {:.6}'.format(best_feature, best_pval))

        # backward step
        model_data = sm.add_constant(pd.DataFrame(X[included]))
        if model_data.select_dtypes(include=[np.number]).shape[1] == model_data.shape[1]:
            if not model_data.isnull().any().any():
                model = sm.OLS(y, model_data).fit()
                pvalues = model.pvalues.iloc[1:]
                worst_pval = pvalues.max()
                if worst_pval > threshold_out:
                    changed = True
                    worst_feature = pvalues.idxmax()
                    included.remove(worst_feature)
                    if verbose:
                        print('Drop {:30} with p-value {:.6}'.format(worst_feature, worst_pval))
        if not changed:
            break
    return included

# Exemplo de uso
X = data.drop("qtKill", axis=1)
y = data["qtKill"]
result = stepwise_selection(X, y)

# Resultado
print("Variáveis selecionadas:")
print(result)

"""Este trecho de código realiza as seguintes operações:

1. **Seleção de Variáveis:**
   - Cria uma lista chamada `selected_variables` contendo os nomes das variáveis que foram selecionadas anteriormente pelo método stepwise ou de alguma outra maneira. As variáveis incluídas são: 'qt1Kill', 'qt5Kill', 'qtShots', 'qt4Kill', 'qtFirstKill', 'qtRoundsPlayed', 'qtDeath', 'qt2Kill', 'vlDamage', 'qtAssist', 'qt3Kill', 'vlLevel', 'flWinner'.
   - Cria um novo DataFrame chamado `selected_data` contendo apenas as colunas correspondentes às variáveis selecionadas no DataFrame original `data`.

2. **Cálculo da Matriz de Correlação:**
   - Usa o método `corr()` do DataFrame `selected_data` para calcular a matriz de correlação entre as variáveis selecionadas.
   - A matriz de correlação mostra as relações lineares entre as variáveis.

3. **Exibição da Matriz de Correlação:**
   - Imprime a matriz de correlação na saída.

A análise da matriz de correlação pode ajudar a entender como as variáveis selecionadas estão relacionadas entre si. Valores próximos de 1 indicam uma forte correlação positiva, valores próximos de -1 indicam uma forte correlação negativa, e valores próximos de 0 indicam uma fraca correlação.

Esse é um passo comum na análise exploratória de dados para entender as relações entre as variáveis antes de prosseguir com a modelagem estatística. Se houver forte correlação entre variáveis independentes, pode ser necessário lidar com multicolinearidade ao ajustar modelos.
"""

# Selecionando as variáveis no DataFrame
selected_variables = ['qt1Kill', 'qt5Kill', 'qtShots', 'qt4Kill', 'qtFirstKill', 'qtRoundsPlayed', 'qtDeath', 'qt2Kill', 'vlDamage', 'qtAssist', 'qt3Kill', 'vlLevel', 'flWinner']
selected_data = data[selected_variables]

# Calculando a matriz de correlação
correlation_matrix = selected_data.corr()

# Exibindo a matriz de correlação
print("Matriz de Correlação:")
print(correlation_matrix)

"""O heatmap é uma forma eficaz de visualizar padrões e forças de correlação entre variáveis em uma matriz de dados. As cores indicam a intensidade e direção da correlação. Valores positivos são geralmente representados por tons mais claros, enquanto valores negativos são representados por tons mais escuros. O argumento cmap='coolwarm' escolhe uma paleta de cores que vai de azul (para valores negativos) a vermelho (para valores positivos)."""

import seaborn as sns
import matplotlib.pyplot as plt

# Configurando a visualização
plt.figure(figsize=(12, 8))
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', fmt=".2f", linewidths=.5)
plt.title("Matriz de Correlação")
plt.show()

"""Esse código realiza uma análise completa de regressão linear múltipla e avalia a qualidade do modelo. Aqui estão as principais inferências que você pode fazer a partir do código:

1. **Ajuste do Modelo de Regressão:**
   - Um modelo de regressão linear múltipla é ajustado usando a biblioteca `statsmodels`.
   - As variáveis independentes são selecionadas e adicionadas ao conjunto de dados.
   - A constante é adicionada ao conjunto de dados.
   - O modelo é ajustado usando o método de mínimos quadrados ordinários (`sm.OLS`).

2. **Resumo do Modelo:**
   - Um resumo estatístico do modelo é impresso usando `model.summary()`. Isso inclui estatísticas como coeficientes, p-valores, R², etc.

3. **Verificação da Homocedasticidade dos Resíduos:**
   - O código verifica se os resíduos (diferenças entre os valores observados e os previstos) têm uma dispersão constante.
   - Um gráfico de dispersão dos resíduos em relação aos valores ajustados é criado usando `plt.scatter`.

4. **Análise do Histograma dos Resíduos:**
   - Um histograma dos resíduos é gerado para verificar a normalidade dos resíduos.
   - `sns.histplot` é usado para criar o histograma.

5. **Gráfico QQ dos Resíduos:**
   - Um gráfico quantil-quantil (QQ) é gerado para verificar se os resíduos seguem uma distribuição normal.
   - `stats.probplot` é usado para criar o gráfico QQ.

Essas etapas ajudam a avaliar a qualidade do modelo e a identificar possíveis problemas, como heterocedasticidade (dispersão não constante dos resíduos) e não normalidade dos resíduos. A homocedasticidade é desejável para que os pressupostos da regressão linear sejam atendidos.

A normalidade dos resíduos é importante para inferências estatísticas válidas. Se os resíduos não seguirem uma distribuição normal, isso pode afetar a confiabilidade dos intervalos de confiança e dos testes de hipóteses associados ao modelo. O gráfico QQ ajuda a comparar a distribuição dos resíduos com uma distribuição normal teórica.

Se essas verificações indicarem problemas, pode ser necessário considerar transformações nas variáveis ou explorar outros modelos para melhorar a adequação do modelo aos dados.
"""

import pandas as pd
import statsmodels.api as sm
import seaborn as sns
import matplotlib.pyplot as plt
from sklearn.preprocessing import StandardScaler
import scipy.stats as stats

# Carregando os dados
data = pd.read_csv("tb_lobby_stats_player.csv")

# Selecionando variáveis
selected_variables = ['qt1Kill', 'qt5Kill', 'qtShots', 'qt4Kill', 'qtFirstKill', 'qtRoundsPlayed',
                       'qtDeath', 'qt2Kill', 'vlDamage', 'qtAssist', 'qt3Kill', 'vlLevel', 'flWinner']

# Criando DataFrame com variáveis selecionadas
selected_data = data[selected_variables]

# Normalizando os dados
scaler = StandardScaler()
selected_data_normalized = scaler.fit_transform(selected_data)

# Adicionando a variável dependente
y = data["qtKill"]

# Adicionando constante ao conjunto de dados
X_normalized = sm.add_constant(selected_data_normalized)

# Ajustando o modelo de regressão linear múltipla
model_normalized = sm.OLS(y, X_normalized).fit()

# Obtendo um resumo do modelo
print(model_normalized.summary())

# Verificando a homocedasticidade dos resíduos (dispersão constante dos resíduos)
fitted_values_normalized = model_normalized.fittedvalues
residuals_normalized = model_normalized.resid

# Gráfico de dispersão dos resíduos
plt.scatter(fitted_values_normalized, residuals_normalized)
plt.xlabel("Valores Ajustados")
plt.ylabel("Resíduos")
plt.title("Gráfico de Dispersão dos Resíduos")
plt.show()

# Histograma dos resíduos
sns.histplot(residuals_normalized, kde=True)
plt.title("Histograma dos Resíduos")
plt.show()

# Gráfico QQ dos resíduos
stats.probplot(residuals_normalized, dist="norm", plot=plt)
plt.title("Gráfico QQ dos Resíduos")
plt.show()